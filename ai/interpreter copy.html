<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Backlog Mum Grafiği (Saatlik/Günlük)</title>

  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

  <style>
    :root{
      --bg:#0b1220;
      --card:#111a2e;
      --muted:#9fb0d0;
      --text:#e9f0ff;
      --line:#243052;
      --accent:#4da3ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:16px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:var(--bg); color:var(--text);
    }
    .wrap{max-width:1200px;margin:0 auto;display:grid;gap:12px}
    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:14px;
      padding:14px 16px;
    }
    .head{
      display:flex; flex-wrap:wrap; gap:12px;
      align-items:flex-end; justify-content:space-between;
    }
    .title h1{margin:0;font-size:18px}
    .title .sub{margin-top:6px;color:var(--muted);font-size:12.5px;line-height:1.4}
    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .btn{
      background:transparent;color:var(--text);
      border:1px solid var(--line);
      border-radius:10px;padding:9px 12px;
      cursor:pointer;font-size:13px;
    }
    .btn:hover{border-color:var(--accent)}
    .btn.active{border-color:var(--accent); box-shadow: 0 0 0 2px rgba(77,163,255,.18) inset;}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    label{color:var(--muted);font-size:12px}
    input[type="datetime-local"]{
      background:transparent; color:var(--text);
      border:1px solid var(--line);
      border-radius:10px;
      padding:8px 10px;
      font-size:12.5px;
    }
    .grid{
      display:grid; gap:12px;
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }
    @media (max-width: 980px){ .grid{grid-template-columns: repeat(2, minmax(0, 1fr));} }
    @media (max-width: 560px){ .grid{grid-template-columns: 1fr;} }
    .kpi .label{color:var(--muted);font-size:12px}
    .kpi .value{margin-top:6px;font-size:20px;font-weight:800}
    .kpi .hint{margin-top:6px;color:var(--muted);font-size:12px}
    .sep{height:1px;background:var(--line);margin:10px 0}
    .note{color:var(--muted);font-size:12px;line-height:1.5}
    code{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      padding: 2px 6px;
      border-radius: 8px;
    }
  </style>
</head>

<body>
<div class="wrap">

  <div class="card">
    <div class="head">
      <div class="title">
        <h1>Backlog Mum Grafiği</h1>
        <div class="sub">
          Mantık: <code>Net = giriş - çıkış</code>, <code>Backlog(t)=Backlog(t-1)+Net</code>.<br/>
          Mum: <code>Open/Close=backlog</code>, <code>High/Low=bucket içi max/min backlog</code>.<br/>
          Y-ekseni ölçeği <b>sabit</b>: tüm dataset min/max değerlerine göre kilitlenir.
        </div>
      </div>

      <div class="controls">
        <button id="btnHourly" class="btn active">Saatlik</button>
        <button id="btnDaily" class="btn">Günlük</button>
        <button id="btnApply" class="btn">Filtreyi Uygula</button>
      </div>
    </div>

    <div class="sep"></div>

    <div class="row">
      <div>
        <label>Başlangıç</label><br/>
        <input id="fromDt" type="datetime-local" />
      </div>
      <div>
        <label>Bitiş</label><br/>
        <input id="toDt" type="datetime-local" />
      </div>

      <div class="note">
        KPI’lar <b>daima tüm dataset</b> üzerinden hesaplanır (filtre KPI’yı değiştirmez).
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="card kpi">
      <div class="label">Toplam Giriş (Genel)</div>
      <div class="value" id="kpiEntryAll">-</div>
      <div class="hint">Tüm zaman</div>
    </div>
    <div class="card kpi">
      <div class="label">Toplam Çıkış (Genel)</div>
      <div class="value" id="kpiExitAll">-</div>
      <div class="hint">Tüm zaman</div>
    </div>
    <div class="card kpi">
      <div class="label">Net (Genel)</div>
      <div class="value" id="kpiNetAll">-</div>
      <div class="hint">Giriş - Çıkış</div>
    </div>
    <div class="card kpi">
      <div class="label">Son Backlog (Genel)</div>
      <div class="value" id="kpiBacklogAll">-</div>
      <div class="hint">Backlog başlangıcı dahil</div>
    </div>
  </div>

  <div class="card">
    <div id="chartCandles"></div>
  </div>

  <div class="card">
    <div id="chartFlow"></div>
  </div>

  <div class="card note">
    <b>Dataset formatı:</b> giriş/çıkış noktaları <code>{ ts: "YYYY-MM-DDTHH:mm:ss", count: number }</code><br/>
    Aşağıdaki JS’te <code>generateSampleData()</code> sadece örnek üretir. Kendi datanı koymak için
    <code>entries</code> ve <code>exits</code> dizilerini değiştirmen yeterli.
  </div>

</div>

<script>
/* =========================================================
   1) ÖRNEK (BÜYÜK) DATASET — 14 gün × saatlik = 336 nokta
   Deterministik üretim (seeded).
   ========================================================= */
function mulberry32(seed){
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function pad2(n){ return String(n).padStart(2,"0"); }
function toIsoLocal(dt){
  // "YYYY-MM-DDTHH:mm:ss"
  return dt.getFullYear()+"-"+pad2(dt.getMonth()+1)+"-"+pad2(dt.getDate())+"T"+pad2(dt.getHours())+":"+pad2(dt.getMinutes())+":"+pad2(dt.getSeconds());
}
function toInputValue(dt){
  // datetime-local expects "YYYY-MM-DDTHH:mm"
  return dt.getFullYear()+"-"+pad2(dt.getMonth()+1)+"-"+pad2(dt.getDate())+"T"+pad2(dt.getHours())+":"+pad2(dt.getMinutes());
}

function generateSampleData(){
  const rnd = mulberry32(42);

  // Başlangıç: 2026-01-20 00:00:00
  const start = new Date("2026-01-20T00:00:00");
  const hours = 14 * 24;

  const entries = [];
  const exits = [];

  // İş yükü dalgalanması + bazı saatler eksik (gap) simülasyonu
  for(let i=0;i<hours;i++){
    const ts = new Date(start.getTime() + i*3600*1000);

    // bazı saatleri eksik bırakalım (gap)
    const drop = rnd() < 0.03; // %3 eksik veri
    if(drop) continue;

    // Gün içi pattern + rastgele gürültü
    const hour = ts.getHours();
    const dayFactor = 0.8 + (Math.sin((i/24)*Math.PI/3)+1)/3; // yavaş dalga
    const hourFactor = (hour>=9 && hour<=18) ? 1.2 : 0.7;     // mesai
    const base = 55 * dayFactor * hourFactor;

    const entry = Math.max(0, Math.round(base + (rnd()*50 - 20)));
    // çıkış: bazen girişin gerisinde kalır, bazen geçer
    const exit = Math.max(0, Math.round(base + (rnd()*60 - 25)));

    entries.push({ ts: toIsoLocal(ts), count: entry });
    exits.push({ ts: toIsoLocal(ts), count: exit });
  }

  return { entries, exits };
}

// ÖRNEK DATA
let { entries, exits } = generateSampleData();

/* =========================================================
   2) Bucket / Resample (hour | day) + gap fill
   ========================================================= */
function parseTs(s){ return new Date(s); }

function bucketKey(dt, mode){
  if(mode === "hour"){
    // YYYY-MM-DDTHH:00:00
    return dt.getFullYear()+"-"+pad2(dt.getMonth()+1)+"-"+pad2(dt.getDate())+"T"+pad2(dt.getHours())+":00:00";
  }
  // day: YYYY-MM-DDT00:00:00
  return dt.getFullYear()+"-"+pad2(dt.getMonth()+1)+"-"+pad2(dt.getDate())+"T00:00:00";
}

function toBucketDate(key){ return new Date(key); }

function sumByBucket(points, mode){
  const m = new Map();
  for(const p of points){
    const dt = parseTs(p.ts);
    const k = bucketKey(dt, mode);
    m.set(k, (m.get(k)||0) + (Number(p.count)||0));
  }
  return m; // key -> sum
}

function buildFullBucketTimeline(minDt, maxDt, mode){
  const out = [];
  const step = (mode === "hour") ? 3600*1000 : 24*3600*1000;

  // Align to bucket boundary
  let cur = new Date(minDt);
  if(mode === "hour"){
    cur.setMinutes(0,0,0);
  }else{
    cur.setHours(0,0,0,0);
  }
  const end = new Date(maxDt);
  while(cur <= end){
    out.push(bucketKey(cur, mode));
    cur = new Date(cur.getTime() + step);
  }
  return out;
}

/* =========================================================
   3) Backlog hesapları + Candles üretimi
   - Backlog başlangıcı: initialBacklog
   - Mum: Open=prevBacklog, Close=newBacklog
          High/Low: bucket içinde backlog max/min
   Not: Bucket içinde tek nokta varsa High/Low genelde Open/Close.
   ========================================================= */
const initialBacklog = 250; // istersen 0 yap veya gerçek devri buraya koy

function buildBacklogCandles(entriesRaw, exitsRaw, mode){
  const entryBuckets = sumByBucket(entriesRaw, mode);
  const exitBuckets  = sumByBucket(exitsRaw, mode);

  // global min/max time from raw
  const allDts = [];
  for(const e of entriesRaw) allDts.push(parseTs(e.ts));
  for(const x of exitsRaw)  allDts.push(parseTs(x.ts));
  allDts.sort((a,b)=>a-b);
  const minDt = allDts[0];
  const maxDt = allDts[allDts.length-1];

  // full bucket timeline (gap fill)
  const timeline = buildFullBucketTimeline(minDt, maxDt, mode);

  let backlog = initialBacklog;
  const candles = [];
  const flow = []; // for bar chart: entry/exit per bucket

  for(const key of timeline){
    const dt = toBucketDate(key);
    const entry = entryBuckets.get(key) || 0;
    const exit  = exitBuckets.get(key) || 0;
    const net   = entry - exit;

    const open = backlog;

    // Bucket içinde “tek adım” varsa high/low, open/close arasıdır.
    // (Daha küçük time-grain'in varsa burada intrabucket max/min de hesaplanabilir.)
    backlog = backlog + net;
    const close = backlog;

    const high = Math.max(open, close);
    const low  = Math.min(open, close);

    candles.push({
      x: dt,
      y: [open, high, low, close],
      _entry: entry,
      _exit: exit,
      _net: net,
      _key: key
    });

    flow.push({
      x: dt,
      entry,
      exit
    });
  }

  return { candles, flow, minDt, maxDt };
}

/* =========================================================
   4) Filtre (görsel) + KPI (daima tüm dataset)
   ========================================================= */
function fmt(n){
  return new Intl.NumberFormat("tr-TR").format(Math.round(n));
}

function computeAllKpis(){
  const totalEntry = entries.reduce((a,p)=>a+(Number(p.count)||0),0);
  const totalExit  = exits.reduce((a,p)=>a+(Number(p.count)||0),0);
  const netAll = totalEntry - totalExit;

  // Son backlog (genel): mode bağımsız, saatlikteki bucket’lar üzerinden hesaplayalım (en detay)
  const { candles } = buildBacklogCandles(entries, exits, "hour");
  const lastCandle = candles[candles.length-1];
  const lastBacklog = lastCandle ? lastCandle.y[3] : initialBacklog;

  document.getElementById("kpiEntryAll").textContent = fmt(totalEntry);
  document.getElementById("kpiExitAll").textContent  = fmt(totalExit);
  document.getElementById("kpiNetAll").textContent   = fmt(netAll);
  document.getElementById("kpiBacklogAll").textContent = fmt(lastBacklog);
}

computeAllKpis();

/* =========================================================
   5) Charts
   - chartCandles: backlog candlestick
   - chartFlow: entries/exits column
   - Y-axis sabit: tüm dataset min/max (seçili aggregation üzerinden)
   ========================================================= */
let mode = "hour";
let candleChart = null;
let flowChart = null;

function withinRange(dt, from, to){
  if(from && dt < from) return false;
  if(to && dt > to) return false;
  return true;
}

function render(){
  const { candles, flow, minDt, maxDt } = buildBacklogCandles(entries, exits, mode);

  // input default set (bir kere)
  const fromEl = document.getElementById("fromDt");
  const toEl   = document.getElementById("toDt");
  if(!fromEl.value) fromEl.value = toInputValue(minDt);
  if(!toEl.value)   toEl.value   = toInputValue(maxDt);

  const from = fromEl.value ? new Date(fromEl.value) : null;
  const to   = toEl.value   ? new Date(toEl.value)   : null;

  // Görsel filtre: sadece chart data kısılır (KPI değişmez)
  const filteredCandles = candles.filter(c => withinRange(c.x, from, to));
  const filteredFlow = flow.filter(f => withinRange(f.x, from, to));

  // Y-axis sabit: tüm dataset (bu aggregation) üzerinden min/max
  let yMin = Infinity, yMax = -Infinity;
  for(const c of candles){
    yMin = Math.min(yMin, c.y[2]); // low
    yMax = Math.max(yMax, c.y[1]); // high
  }
  if(!isFinite(yMin) || !isFinite(yMax)){ yMin = 0; yMax = 1; }
  const pad = Math.max(5, Math.round((yMax - yMin) * 0.05));
  yMin -= pad; yMax += pad;

  // Candlestick
  const candleOptions = {
    chart: { type:"candlestick", height: 420, toolbar:{ show:true } },
    series: [{ name:"Backlog", data: filteredCandles.map(c => ({ x: c.x, y: c.y })) }],
    xaxis: { type:"datetime" },
    yaxis: {
      min: yMin,
      max: yMax,
      labels: { formatter: (v)=> fmt(v) }
    },
    tooltip: {
      custom: function({seriesIndex, dataPointIndex, w}){
        const dp = w.globals.initialSeries[seriesIndex].data[dataPointIndex];
        if(!dp) return "";
        const dt = new Date(dp.x);
        const dateStr = dt.toLocaleString("tr-TR");

        // filteredCandles ile index eşleşir:
        const meta = filteredCandles[dataPointIndex];
        const o = dp.y[0], h = dp.y[1], l = dp.y[2], c = dp.y[3];
        const entry = meta? meta._entry : 0;
        const exit  = meta? meta._exit  : 0;
        const net   = meta? meta._net   : 0;

        const dir = (c < o) ? "Backlog arttı" : (c > o ? "Backlog azaldı" : "Backlog sabit");
        return `
          <div style="padding:10px 12px; font-size:12px; line-height:1.55;">
            <div style="font-weight:800; margin-bottom:6px;">${dateStr}</div>
            <div>Entry: <b>${fmt(entry)}</b> | Exit: <b>${fmt(exit)}</b> | Net: <b>${fmt(net)}</b></div>
            <div style="margin-top:6px;">Open: <b>${fmt(o)}</b> | High: <b>${fmt(h)}</b></div>
            <div>Low: <b>${fmt(l)}</b> | Close: <b>${fmt(c)}</b></div>
            <div style="margin-top:6px; opacity:.85;">${dir}</div>
          </div>
        `;
      }
    }
  };

  if(candleChart){
    candleChart.updateOptions(candleOptions, true, true);
  }else{
    candleChart = new ApexCharts(document.querySelector("#chartCandles"), candleOptions);
    candleChart.render();
  }

  // Flow chart (Entry/Exit bar)
  const flowOptions = {
    chart: { type:"bar", height: 260, toolbar:{ show:true } },
    series: [
      { name: "Giriş", data: filteredFlow.map(p => ({ x: p.x, y: p.entry })) },
      { name: "Çıkış", data: filteredFlow.map(p => ({ x: p.x, y: p.exit })) }
    ],
    xaxis: { type:"datetime" },
    plotOptions: { bar: { columnWidth: "55%" } },
    dataLabels: { enabled: false },
    yaxis: { labels: { formatter: (v)=> fmt(v) } },
    tooltip: { shared: true, x: { format: "dd.MM.yyyy HH:mm" } }
  };

  if(flowChart){
    flowChart.updateOptions(flowOptions, true, true);
  }else{
    flowChart = new ApexCharts(document.querySelector("#chartFlow"), flowOptions);
    flowChart.render();
  }
}

render();

/* =========================================================
   6) UI events
   ========================================================= */
const btnHourly = document.getElementById("btnHourly");
const btnDaily  = document.getElementById("btnDaily");
const btnApply  = document.getElementById("btnApply");

btnHourly.addEventListener("click", () => {
  mode = "hour";
  btnHourly.classList.add("active");
  btnDaily.classList.remove("active");
  render();
});

btnDaily.addEventListener("click", () => {
  mode = "day";
  btnDaily.classList.add("active");
  btnHourly.classList.remove("active");
  render();
});

btnApply.addEventListener("click", () => render());
</script>
</body>
</html>
